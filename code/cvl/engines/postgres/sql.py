"""
Temporary tables have a _ prefix
columns generated by CVL have a cvl_ prefix
framework functions have a CVL_ prefix
"""
__author__ = 'kostas'

# BASIC TRANSACTION

BEGIN_TX = \
    """
    BEGIN;
    """

COMMIT_TX = \
    """
    COMMIT;
    """

# INIT


DROP_OUTPUT_TABLE = \
    """
    DROP TABLE IF EXISTS {output};
    """

CREATE_OUTPUT_TABLE_AND_INDEX = \
    """
    CREATE TABLE {output} AS
    SELECT
      {fid}::bigint as cvl_id, {geometry}, {other}
      {rank_by}::float AS cvl_rank,
      0 as cvl_zoom
    FROM
      {input};

    --CREATE INDEX {output}_zidx ON {output} (cvl_zoom);
    CREATE INDEX {output}_gist ON {output} USING GIST({geometry});
    """

# CVL

# Stage commands

CREATE_TEMPORARY = \
    """
    CREATE TEMPORARY TABLE _conflicts (conflict_id text, cvl_id bigint, cvl_rank float, min_hits integer);
    CREATE TEMPORARY TABLE _deletions (cvl_id bigint);
    CREATE TEMPORARY VIEW _level_view AS SELECT * FROM {output} WHERE cvl_zoom = 0;
    """

FIND_CONFLICTS = \
    """
    INSERT INTO _conflicts
    SELECT
        conflicts.conflict_id,
        conflicts.cvl_id,
        level.cvl_rank,
        conflicts.min_hits
    FROM ({constraint_select}) conflicts
    JOIN _level_view level
    ON conflicts.cvl_id = level.cvl_id;
    """

SOLVE = \
    """
    INSERT INTO _deletions
    SELECT sol.* FROM ({solution}) sol;
    """

DO_DELETIONS = \
    """
    UPDATE {output}
    SET cvl_zoom = {z} + 1
    WHERE cvl_id IN (SELECT cvl_id FROM _deletions);
    """

DROP_TEMPORARY = \
    """
    DROP TABLE _conflicts;
    DROP TABLE _deletions;
    DROP VIEW _level_view;
    """

# COMMENTS

COMMENT = "-- {comment}"


DO_LOG = \
    r"""
    DO $$
        from datetime import datetime
        with open('{log_path}', 'a+') as f:
            to_write = " ".join([datetime.now().strftime("%d/%m/%Y %H:%M:%S.%f"), '{message}'])
            f.write(to_write)
            f.write('\n')
    $$ LANGUAGE plpythonu;
    """

DO_LOG_LEVELSTATS = \
    r"""
    DO $$
        from datetime import datetime

        stats = dict([])

        sql = "SELECT sum(cvl_rank) as rank_lost, count(*) recs_lost FROM {output} WHERE cvl_zoom = {z} + 1;"
        rows = plpy.execute(sql)
        stats['rank_lost'] = rows[0]['rank_lost'] or 0.0
        stats['recs_lost'] = rows[0]['recs_lost'] or 0.0

        sql = "SELECT sum(cvl_rank) AS rank_remaining, count(*) AS recs_remaining FROM {output} WHERE cvl_zoom = 0"
        rows = plpy.execute(sql)
        stats['rank_remaining'] = rows[0]['rank_remaining'] or 0.0
        stats['recs_remaining'] = rows[0]['recs_remaining'] or 0.0

        sql = (
            "SELECT count(t.cnt) as num_recs_having_c, min(t.cnt) as cmin, max(t.cnt) as cmax, avg(t.cnt) as cavg"
            " FROM (SELECT count(*) AS cnt FROM _conflicts GROUP BY cvl_id) t;"
        )
        rows = plpy.execute(sql)
        stats['num_recs_having_c'] = rows[0]['num_recs_having_c'] or 0.0
        stats['c_per_rec_min'] = rows[0]['cmin'] or 0.0
        stats['c_per_rec_max'] = rows[0]['cmax'] or 0.0
        stats['c_per_rec_avg'] = rows[0]['cavg'] or 0.0

        sql = (
            "SELECT count(t.cnt) as num_c, min(t.cnt) as rmin, max(t.cnt) as rmax, avg(t.cnt) as ravg"
            " FROM (SELECT count(*) AS cnt FROM _conflicts GROUP BY conflict_id) t;"
        )
        rows = plpy.execute(sql)
        stats['num_c'] = rows[0]['num_c'] or 0.0
        stats['rec_per_c_min'] = rows[0]['rmin'] or 0.0
        stats['rec_per_c_max'] = rows[0]['rmax'] or 0.0
        stats['rec_per_c_avg'] = rows[0]['ravg'] or 0.0

        sql = "SELECT CVL_LPBound('_conflicts') as lowerbound;"
        rows = plpy.execute(sql)
        stats['lp_bound'] = rows[0]['lowerbound'] or 0.0

        with open('{log_path}', 'a+') as f:
            for row in rows:
                to_write = " ".join([
                    datetime.now().strftime("%d/%m/%Y %H:%M:%S.%f"),
                    '{job_name}',
                    'levelstats',
                    str(stats)
                ])
                f.write(to_write)
                f.write('\n')
    $$ LANGUAGE plpythonu;
    """

DO_LOG_INPUTSTATS = \
    r"""
    DO $$
        from datetime import datetime

        sql = "SELECT Count(*) as total_recs, Sum(cvl_rank) AS total_rank  \
               FROM {output};"
        rows = plpy.execute(sql)
        stats = dict([])
        stats['total_recs'] = rows[0]['total_recs']
        stats['total_rank'] = rows[0]['total_rank']

        sql = "SELECT array_agg(DISTINCT GeometryType({geometry})) as geometry_types FROM {output};"
        rows = plpy.execute(sql)
        stats['geometry_types'] = rows[0]['geometry_types']

        with open('{log_path}', 'a+') as f:
            for row in rows:
                to_write = " ".join([
                    datetime.now().strftime('%d/%m/%Y %H:%M:%S.%f'),
                    '{job_name}', 'inputstats',
                    str(stats)
                ])
                f.write(to_write)
                f.write('\n')
    $$ LANGUAGE plpythonu;
    """

ANALYZE = \
    r"""
    ANALYZE {output};
    """
