"""
Temporary tables have a _ prefix
columns generated by CVL have a cvl_ prefix
framework functions have a CVL_ prefix
"""
__author__ = 'kostas'

# BASIC TRANSACTION

BEGIN_TX = \
    """
    BEGIN;
    """

COMMIT_TX = \
    """
    COMMIT;
    """

# INIT

# FRAMEWORK

ADD_FRAMEWORK = \
    r"""
    -- create extension plpythonu;

    CREATE TYPE lp_result AS (
        cvl_id bigint,
        cvl_rank double precision,
        lp_value double precision
    );

    CREATE OR REPLACE FUNCTION CVL_LP
    (
      conflict_table text
    ) RETURNS SETOF lp_result AS
    $$
        import cvxopt
        from math import ceil, floor
        from cvxopt import matrix, spmatrix, sparse, solvers

        SELECT_CONFLICTS = \
            (
                "SELECT"
                " array_agg(cvl_id) as cvl_ids,"
                " (SELECT min_hits FROM {conflict_table} t2 WHERE t1.conflict_id = t2.conflict_id LIMIT 1)"
                " FROM"
                " {conflict_table} t1"
                " GROUP BY"
                " conflict_id"
            )

        # get conflicts
        sql = SELECT_CONFLICTS.format(conflict_table=conflict_table)
        conflicts = plpy.execute(sql)
        if not conflicts:
            return

        # get variables
        sql = "SELECT cvl_id, min(cvl_rank) as cvl_rank FROM {conflict_table} GROUP BY cvl_id".format(conflict_table=conflict_table)
        variables = plpy.execute(sql)
        variables = dict(map(
            lambda (pos,x): (x['cvl_id'], {'cvl_rank': x['cvl_rank'], 'pos': pos}),
            enumerate(variables)
        ))
        i_to_var = dict([(value['pos'], key) for (key,value) in variables.items()])

        # b: non-neg, less-than-one, min_hits
        _b = matrix([0.0] * len(variables) + [1.0] * len(variables) + [-c['min_hits'] for c in conflicts])

        # c: ranks
        _c = matrix([variables[v]['cvl_rank'] for v in variables])

        # A:
        non_neg = spmatrix(-1.0, range(len(variables)), range(len(variables)))
        less_than_one = spmatrix(1.0, range(len(variables)), range(len(variables)))
        I = []
        J = []
        for i, cflt in enumerate(conflicts):
            for v in cflt['cvl_ids']:
                I.append(i)
                J.append(variables[v]['pos'])
        csets = spmatrix(-1.0, I, J)

        _A = sparse([non_neg, less_than_one, csets])

        solvers.options['show_progress'] = False
        sol = solvers.lp(_c, _A, _b)

        if sol['status'] == 'optimal':
            for i, lp_value in enumerate(sol['x']):
                cvl_id = i_to_var[i]
                cvl_rank = variables[cvl_id]['cvl_rank']
                yield {'cvl_id': cvl_id, 'cvl_rank': cvl_rank, 'lp_value': lp_value}
        else:
            plpy.error("Infeasible LP instance detected by solver!")

    $$ LANGUAGE plpythonu;

    CREATE OR REPLACE FUNCTION CVL_LPBOUND
    (
        conflict_table text
    ) RETURNS double precision AS
    $$
        SELECT sum(lp_value * cvl_rank) FROM CVL_LP('_conflicts');
    $$ LANGUAGE sql VOLATILE;


    -- CVL_CellSizeZ

    CREATE OR REPLACE FUNCTION CVL_CellSizeZ
    (
      z integer,
      OUT meter_per_pixel float
    ) RETURNS float AS
    $$
    SELECT 40075016.68 / power(2, $1)
    $$ LANGUAGE sql IMMUTABLE STRICT;

    -- CVL_PointHash

    CREATE OR REPLACE FUNCTION CVL_PointHash
    (
      pt geometry,
      OUT geohash text
    ) RETURNS text AS
    $$
    SELECT
      ST_GeoHash
      (
        ST_Transform
        (
          $1,
          4326
        )
      ) AS geohash;
    $$ LANGUAGE sql IMMUTABLE STRICT;

    -- CVL_Cellify

    CREATE OR REPLACE FUNCTION CVL_Cellify
    (
      geom geometry,
      cell_size float8,
      x0 float8 DEFAULT 0,
      y0 float8 DEFAULT 0,
      OUT pt geometry
    ) RETURNS SETOF geometry AS
    $$
    SELECT
    *
    FROM
    (
      SELECT
        ST_SnapToGrid
        (
          ST_SetSrid
          (
            ST_Point
            (
              ST_XMin($1) + i*$2,
              ST_YMin($1) + j*$2
            ),
            ST_Srid($1)
          ),
          $3 + $2/2,
          $4 + $2/2,
          $2,
          $2
        ) AS pt
      FROM
        generate_series(0, (ceil(ST_XMax( $1 ) - ST_Xmin( $1 )) / $2)::integer) AS i,
        generate_series(0, (ceil(ST_YMax( $1 ) - ST_Ymin( $1 )) / $2)::integer) AS j
    ) PT
    WHERE
      ST_Distance($1, ST_Expand(PT.pt, $2/2)) = 0;
    $$ LANGUAGE sql IMMUTABLE STRICT;

    CREATE OR REPLACE FUNCTION CVL_CellForPoint
    (
      geom geometry,
      cell_size float8,
      x0 float8 DEFAULT 0,
      y0 float8 DEFAULT 0,
      OUT pt geometry
    ) RETURNS SETOF geometry AS
    $$
      SELECT ST_SnapToGrid
      (
        $1,
        $3 + $2/2,
        $4 + $2/2,
        $2,
        $2
      );
    $$ LANGUAGE sql IMMUTABLE STRICT;

    -- web mercator cells

    CREATE OR REPLACE FUNCTION CVL_WebMercatorCells
    (
      geom geometry,
      zoom integer,
      OUT pt geometry
    ) RETURNS SETOF geometry AS
    $$
    SELECT
      CASE
        WHEN GeometryType($1)='POINT' THEN CVL_CellForPoint($1, CVL_CellSizeZ($2), -20037508.34, -20037508.34)
        ELSE CVL_Cellify($1, CVL_CellSizeZ($2), -20037508.34, -20037508.34)
      END AS pt

    $$ LANGUAGE sql IMMUTABLE STRICT;

    -- CVL_ResZ

    CREATE OR REPLACE FUNCTION CVL_ResZ
    (
      z integer,
      tilesize integer,
      OUT meter_per_pixel float
    ) RETURNS float AS
    $$
    SELECT (40075016.68 / power(2, $1)) / $2
    $$ LANGUAGE sql IMMUTABLE STRICT;
    """

REMOVE_FRAMEWORK = \
    """
    DROP FUNCTION CVL_LP(text);
    DROP FUNCTION CVL_LPBound(text);
    DROP TYPE lp_result;
    DROP FUNCTION CVL_PointHash(geometry);
    DROP FUNCTION CVL_WebMercatorCells(geometry, integer);
    DROP FUNCTION CVL_Cellify(geometry, float8, float8, float8);
    DROP FUNCTION CVL_CellForPoint(geometry, float8, float8, float8);
    DROP FUNCTION CVL_ResZ(integer,integer);
    DROP FUNCTION CVL_CellSizeZ(integer);
    """

DROP_OUTPUT_TABLE = \
    """
    DROP TABLE IF EXISTS {output};
    """

CREATE_OUTPUT_TABLE_AND_INDEX = \
    """
    CREATE TABLE {output} AS
    SELECT
      {fid}::bigint as cvl_id, {geometry}, {other}
      {rank_by}::float AS cvl_rank,
      0 as cvl_zoom
    FROM
      {input};

    --CREATE INDEX {output}_zidx ON {output} (cvl_zoom);
    CREATE INDEX {output}_gist ON {output} USING GIST({geometry});

    ANALYZE;
    """

# CVL

# Stage commands

CREATE_TEMPORARY = \
    """
    CREATE TEMPORARY TABLE _conflicts (conflict_id text, cvl_id bigint, cvl_rank float, min_hits integer);
    CREATE TEMPORARY TABLE _deletions (cvl_id bigint);
    CREATE TEMPORARY VIEW _level_view AS SELECT * FROM {output} WHERE cvl_zoom = 0;
    """

FIND_CONFLICTS = \
    """
    INSERT INTO _conflicts
    SELECT
        conflicts.conflict_id,
        conflicts.cvl_id,
        level.cvl_rank,
        conflicts.min_hits
    FROM ({constraint_select}) conflicts
    JOIN _level_view level
    ON conflicts.cvl_id = level.cvl_id;
    """

SOLVE = \
    """
    INSERT INTO _deletions
    SELECT sol.* FROM ({solution}) sol;
    """

DO_DELETIONS = \
    """
    UPDATE {output}
    SET cvl_zoom = {z} + 1
    WHERE cvl_id IN (SELECT cvl_id FROM _deletions);
    """

DROP_TEMPORARY = \
    """
    DROP TABLE _conflicts;
    DROP TABLE _deletions;
    DROP VIEW _level_view;
    """

# COMMENTS

COMMENT = "-- {comment}"


DO_LOG = \
    r"""
    DO $$
        from datetime import datetime
        with open('{log_path}', 'a+') as f:
            to_write = " ".join([datetime.now().strftime("%d/%m/%Y %H:%M:%S.%f"), '{message}'])
            f.write(to_write)
            f.write('\n')
    $$ LANGUAGE plpythonu;
    """

DO_LOG_LEVELSTATS = \
    r"""
    DO $$
        from datetime import datetime

        stats = dict([])

        sql = "SELECT sum(cvl_rank) as rank_lost, count(*) recs_lost FROM {output} WHERE cvl_zoom = {z} + 1;"
        rows = plpy.execute(sql)
        stats['rank_lost'] = rows[0]['rank_lost'] or 0.0
        stats['recs_lost'] = rows[0]['recs_lost'] or 0.0

        sql = "SELECT sum(cvl_rank) AS rank_remaining, count(*) AS recs_remaining FROM {output} WHERE cvl_zoom = 0"
        rows = plpy.execute(sql)
        stats['rank_remaining'] = rows[0]['rank_remaining'] or 0.0
        stats['recs_remaining'] = rows[0]['recs_remaining'] or 0.0

        sql = (
            "SELECT count(t.cnt) as num_recs_having_c, min(t.cnt) as cmin, max(t.cnt) as cmax, avg(t.cnt) as cavg"
            " FROM (SELECT count(*) AS cnt FROM _conflicts GROUP BY cvl_id) t;"
        )
        rows = plpy.execute(sql)
        stats['num_recs_having_c'] = rows[0]['num_recs_having_c'] or 0.0
        stats['c_per_rec_min'] = rows[0]['cmin'] or 0.0
        stats['c_per_rec_max'] = rows[0]['cmax'] or 0.0
        stats['c_per_rec_avg'] = rows[0]['cavg'] or 0.0

        sql = (
            "SELECT count(t.cnt) as num_c, min(t.cnt) as rmin, max(t.cnt) as rmax, avg(t.cnt) as ravg"
            " FROM (SELECT count(*) AS cnt FROM _conflicts GROUP BY conflict_id) t;"
        )
        rows = plpy.execute(sql)
        stats['num_c'] = rows[0]['num_c'] or 0.0
        stats['rec_per_c_min'] = rows[0]['rmin'] or 0.0
        stats['rec_per_c_max'] = rows[0]['rmax'] or 0.0
        stats['rec_per_c_avg'] = rows[0]['ravg'] or 0.0

        sql = "SELECT CVL_LPBound('_conflicts') as lowerbound;"
        rows = plpy.execute(sql)
        stats['lp_bound'] = rows[0]['lowerbound'] or 0.0

        with open('{log_path}', 'a+') as f:
            for row in rows:
                to_write = " ".join([
                    datetime.now().strftime("%d/%m/%Y %H:%M:%S.%f"),
                    '{job_name}',
                    'levelstats',
                    str(stats)
                ])
                f.write(to_write)
                f.write('\n')
    $$ LANGUAGE plpythonu;
    """

DO_LOG_INPUTSTATS = \
    r"""
    DO $$
        from datetime import datetime

        sql = "SELECT Count(*) as total_recs, Sum(cvl_rank) AS total_rank  \
               FROM {output};"
        rows = plpy.execute(sql)
        stats = dict([])
        stats['total_recs'] = rows[0]['total_recs']
        stats['total_rank'] = rows[0]['total_rank']

        sql = "SELECT array_agg(DISTINCT GeometryType({geometry})) as geometry_types FROM {output};"
        rows = plpy.execute(sql)
        stats['geometry_types'] = rows[0]['geometry_types']

        with open('{log_path}', 'a+') as f:
            for row in rows:
                to_write = " ".join([
                    datetime.now().strftime('%d/%m/%Y %H:%M:%S.%f'),
                    '{job_name}', 'inputstats',
                    str(stats)
                ])
                f.write(to_write)
                f.write('\n')
    $$ LANGUAGE plpythonu;
    """
