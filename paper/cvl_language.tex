% !TEX root = ./cvl.tex
\section{CVL Language}
\label{sec:cvl-language}
The Cartographic Visualization Language (CVL) is a declarative language for filtering a geospatial dataset over a set of zoom-levels. CVL is a rule-based language with a similar goal as other rule-based languages for generalizing spatial datasets such as Styled Layer Descriptor and Mapnik XML~\cite{sld,mapnik}. The CVL approach is however markedly different. In the related languages the user must explicitly control the filtering of records at each zoom-level, while also specifying how records are rendered (presentation). First of all, CVL is not concerned with presentation, only filtering. Furthermore CVL controls filtering in a novel way compared to these languages. Instead of having the user explicitely control the filtering of records at each zoom-level, CVL lets the user choose \emph{cartographic constraints} that are enforced at all zoom-levels. By making the constraints explicit and the control implicit a very concise formulation is obtained, see Section~\ref{sec:generalize-statement}.

CVL is one of the first languages and frameworks to implement the idea behind reverse data management~\cite{reverse}. In reverse data management, the core idea is that a user states a set of constraints and objective. These are given together with an input database to an optimization algorithm which computes an output database that is feasible and optimal with regard to the constraints and objective (if a feasible solution exists). This is exactly how CVL works. 

The CVL language builds on top of SQL and reuses SQL as a language for formulating constraints and objectives. By using an existing language for this purpose, users who already know SQL can immediately begin formulating their own cartographic constraints and record weighing schemes in CVL. We will give example of a few constraints and weighing schemes in Section~\ref{sec:generalize-statement} and Section~\ref{sec:create-constraint}. Overall, CVL is designed to be very concise, using as little as four lines of code, and is designed to be usable by people with intermediate knowledge of geographical data and programming. Users don't even need to know SQL, as CVL comes with several constraints built-in.

The CVL language has two statements, the \emph{generalize} statement and the \emph{create constraint} statement. The create constraint statement is used to formulate new cartographic constraints and the generalize statement is used for everything else. 

\subsection{Generalize statement}
\label{sec:generalize-statement}

The generalize statement is the main statement in CVL. This statement creates a new multi-scale dataset from an input table of geospatial records, subject to user defined constraints. The syntax is shown in Figure~\ref{fig:generalize-syntax}. The statement has several clauses, including a specification of input and output tables, weighing of records, listing (but not defining) the constraints to enforce and the number of zoom-levels to generalize for. 

For clarity the syntax is shown without clauses for naming the ID and geometry columns in the input. These clauses are entirely straight forward and need no further explanation.

\begin{figure}[htbp]
\begin{center}
\begin{lstlisting}
GENERALIZE 
   {input} TO {output}
AT {integer} ZOOM LEVELS
WEIGH BY
  {float expression}

SUBJECT TO 
   {constraint} {float parameters} [AND
   {constraint} {float parameters} [AND
   ...]]
\end{lstlisting}
\caption{Syntax of generalize statement}
\label{fig:generalize-syntax}
\end{center}
\end{figure}

An example of generalizing a dataset using the generalize statement is shown in Figure~\ref{fig:cvl-example-airports}. In this example a dataset containing the location of airports is generalized. The records are weighted by using a column containing the number of routes departing from each airport. The intuition is that airports with more departures are more important. The single constraint that is enforced is the proximity constraint, with a parameter of $10$ pixels.

\begin{figure}[htbp]
\begin{center}
\begin{lstlisting}
GENERALIZE 
   airports TO airports2
AT 18 ZOOM LEVELS
WEIGH BY
  num_departures
SUBJECT TO 
   proximity 10 
\end{lstlisting}
\caption{Example: Generalizing an airports dataset, weighting the airports by number of departures}
\label{fig:cvl-example-airports}
\end{center}
\end{figure}


%An advanced example using a select statement as input, using two constraints and accounting for null values in the column used to weight the records is shown in Figure~\ref{fig:cvl-example-restaurants}.

%\begin{figure}[htbp]
%\begin{center}
%\begin{lstlisting}
%GENERALIZE 
%   (select * from amenities 
%    where type='restaurant') t TO restaurants
%AT 18 ZOOM LEVELS
%WEIGH BY
%  CASE 
%    WHEN stars IS NULL THEN 0.5
%    ELSE stars
%  END
%SUBJECT TO 
%   proximity 10 AND
%   cellbound 16
%\end{lstlisting}
%\caption{Example: Advanced usage}
%\label{fig:cvl-example-restaurants}
%\end{center}
%\end{figure}


\subsection{Create constraint statement}
\label{sec:create-constraint-statement}

% change text
In the example shown in Figure~\ref{fig:cvl-example-airports} we referenced an as yet undefined constraint, the proximity constraint. Cartographic constraints are defined using the \emph{create constraint} statement.  The basic syntax of the statement is shown in Figure~\ref{fig:create-constraint-syntax}. The body of the statement is an SQL select statement that selects tuples $\langle cid, rid\rangle$ representing conflicts in the map, as explained in Section~\ref{sec:???}.

The \emph{resolve-if-delete} clause is used to compute the integer number of records that must be deleted in order to resolve the conflict with a given $cid$.

\begin{figure}[htbp]
\begin{center}
\begin{lstlisting}
CREATE CONSTRAINT C1
AS NOT EXISTS
  {SQL select statement}
RESOLVE cid IF DELETE (
  {integer expression}
)
\end{lstlisting}
\caption{Syntax of create constraint statement}
\label{fig:create-constraint-syntax}
\end{center}
\end{figure}

An example of defining a constraint is shown in Figure~\ref{fig:proximity-definition}. In this example the proximity constraint is defined. The body of the constraint is a distance self join using a distance function \texttt{ST\_Distance} provided by a spatial extension to SQL. This join finds all pairs of records that are too close, i.e. less than $10$ pixels apart if running the example in Figure~\ref{fig:cvl-example-airports}. For each conflict the select statement outputs two tuples and exactly once for each conflict. The resolve-if-delete clause is simply the constant $1$, because that is how many records must be deleted to resolve a proximity conflict.

\begin{figure}[htbp]
\begin{center}
\begin{lstlisting}
CREATE CONSTRAINT Proximity
AS NOT EXISTS (
  SELECT 
    l.{rid} || r.{rid} AS cid,
    Unnest(array[l.{rid}, r.{rid}]) AS rid
  FROM
    {level_view} l
  JOIN
    {level_view} r
  ON
    l.{rid} < r.{rid}
  AND
    ST_Distance(l.{geom}, r.{geom}) <
      CVL_Resolution({z}, 256) * {parameter_1}
)
RESOLVE cid IF DELETE (
  1
)
\end{lstlisting}
\caption{Definition of the proximity constraint}
\label{fig:proximity-definition}
\end{center}
\end{figure}

In the example in Figure~\ref{fig:proximity-definition} you'll notice some names enclosed in curly braces like \texttt{\{rid\}}. These are variables which are bound at runtime by the CVL framework and are intended for making the definition of constraints simpler. The variables \texttt{\{rid\}} and \texttt{\{geom\}} are bound to the column names containing the ID and geometry of the records. The \texttt{\{level\_view\}} variable is bound to the name of a view that contains all records that are visible at the current level. You'll also notice a call to a function \texttt{CVL\_Resolution(\{z\}, 256)}. This is one of the utility functions defined by the CVL runtime, also with the purpose of making the definition of constraints simpler. This function returns the resolution (meter/pixel) at zoom-level \texttt{\{z\}}, where \texttt{\{z\}} is a variable bound to the currently evaluated zoom-level. The variable \texttt{\{parameter\_1\}} would be bound to $10$ if running the example in Figure~\ref{fig:cvl-example-airports}.

A constraint with a more elaborate definition is the \emph{cellbound} constraint (also known as the \emph{visibility} constraint~\cite{sarma2012fusiontables}). The definition is shown in Figure~\ref{fig:cellbound-definition}. This constraint states that tiles on any zoom-level may be intersected by at most $K$ records. The definition uses an extension of the basic create-constraint syntax, namely clauses (\texttt{SETUP} and \texttt{CLEAN UP}) that contain SQL that is run before and after the constraint body is evaluated at each zoom-level. During the setup phase we create an auxiliary table called \texttt{busted\_tiles} which contains tuples $\langle tile\_id, rid \rangle$ identifying tiles that are intersected by more than $K$ records, and the ID of those records. The body of the constraint simply iterates over the auxiliary table.

In this example, calls are made to other CVL runtime functions, namely \texttt{CVL\_WebMercatorCells} and \texttt{CVL\_PointHash}. These functions returns a set of points corresponding to the centroids of intersected tiles (given a geometry) and a unique identifier for points, respectively. The unique identifier for points is based on the well-known GeoHash algorithm.

\begin{figure}[htbp]
\begin{center}
\begin{lstlisting}
CREATE CONSTRAINT Cellbound
AS NOT EXISTS (
    SELECT
        busted_tiles.cid,
        busted_tiles.rid
    FROM
        busted_tiles
)
RESOLVE cid IF DELETE (
  SELECT count(*) - {parameter_1}
  FROM   busted_tiles bt
  WHERE  bt.cid = cid
)
WITH SETUP (
    CREATE TEMPORARY TABLE busted_tiles AS (
        SELECT
            t.cid,
            Unnest(array_agg(t.cvl_id)) AS rid
        FROM
        (
        SELECT
            CVL_PointHash(CVL_WebMercatorCells({geometry}, {z})) AS cid,
            {rid}
        FROM
            {level_view}
        ) t
        GROUP BY t.cid
        HAVING count(*) > {parameter_1}
    );
    CREATE INDEX busted_tiles_id_idx ON busted_tiles (cid);
)
WITH CLEAN UP (
  DROP TABLE busted_tiles;
)
\end{lstlisting}
\caption{Definition of cellbound constraint}
\label{fig:cellbound-definition}
\end{center}
\end{figure}

% give the variables by example, and explain together with the example, instead of listing everything up front.

%\marcos{These could be introduced by need along with the examples integrated into the sections above.}
