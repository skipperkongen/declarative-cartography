% !TEX root = ./cvl.tex
\section{CVL language}
\label{sec:cvl-language}
CVL is a declarative language for generalizing a spatial dataset. It is designed to be very concise, typically no more than ten lines of code, and to be usable by non-cartographers. The language has only two statements, the \emph{generalize} statement and the \emph{create constraint} statement. 



The create constraint statement is use to augment CVL with new cartographic constraints.

\subsection{Generalize statement}
The generalize statement is used to transform an input spatial dataset to a multi-scale output dataset, which is well-suited for display on a zoomable map such as the web maps that have gained immense popularity over the last ten years. The generalize statement has several clauses, some of which are mandatory. 

\subsubsection{input-output clause}

The \emph{input-output} clause is mandatory. It is parameterized by the names of input and output datasets, and the record fields holding the ID and geometry data. The clause has the following syntax:

\begin{lstlisting}
GENERALIZE 
   {input} TO {output}
WITH ID
   {field}
WITH GEOMETRY 
   {field}
\end{lstlisting}

\subsubsection{with-other clause}

The \emph{with-other} clause is optional. It is parameterized by a list of field names that should be copied from input to output. If the clause is omitted, only the ID and geometry field are copied. The clause has the following syntax:

\begin{lstlisting}
WITH OTHER {list of fields}
\end{lstlisting}

\subsubsection{zoom-levels clause}

The \emph{zoom-levels} clause is mandatory. It is parameterized by a positive integer which is the number of zoom-levels that the input should be generalized for. Zoom-levels run from 1 (lowest scale) to some positive integer $\mathcal{Z}$ (largest scale) typically less than the number 20. The clause has the following syntax:

\begin{lstlisting}
AT {integer} ZOOM LEVELS
\end{lstlisting}

\subsubsection{rank-by clause}

The \emph{rank by} clause is optional. It is used to differentiate between "important" and "unimportant" records. It is parameterized by an expression that evaluates to a floating point number. The expression is anything that could occur in an SQL select clause. An example is a call to the \texttt{random()} function in SQL. If the clause is left out, records are ranked by the constant $1$. This clause has the following syntax:

\begin{lstlisting}
RANK BY {float expr}
\end{lstlisting}

\subsubsection{partition-by clause}

The \emph{partition by} clause is optional. It is used to split the input into partitions which are generalized separately by the CVL system. It is parameterized by a scalar expression, which can be any expression that could occur in an SQL select clause. An example is the name of a field in the input, which can be used to partition the data. Partitions are treated separately by the CVL interpreter. If no clause is given, all records are partitioned by the constant $1$. 

\begin{lstlisting}
PARTITION BY
   {scalar expr}
\end{lstlisting}

\subsubsection{merge-partitions clause}

The \emph{merge-partitions} clause is optional, but requires the \emph{partition-by} clause to be also present. It is used to combine several partitions produced by the partition-by clause into a single partition. This is useful if some partitions contains very little data. It is parameterized by a list of tuples. The first tuple-element is a list of partitions created using the partition-by clause. The second tuple-element is a scalar value to use as the new partition value. A special wild-card partition name can be used to group any remaining partitions into a single partition.

\begin{lstlisting}
MERGE PARTITIONS    
    {partitions} AS {scalar expr}
AND 
   {partitions} AS {scalar expr}]
...
AND 
   * AS {scalar expr}
\end{lstlisting}

\subsubsection{subject-to clause}

The \emph{subject-to} clause is arguably the most important one, but is also optional. It is used to drive the selection of records at coarser zoom-levels. The subject-to clause states the cartographic constraints that must hold for each partition at each zoom-level. Constraint are parameterized by a constraint name and a list of float-values which have constraint specific semantics. The syntax allows for several constraints to be given:

\begin{lstlisting}
SUBJECT TO 
   {constraint} {float parameters} 
AND
   {constraint} {float parameters}
...
\end{lstlisting}

\subsubsection{force-level clause}

The user may optionally choose to manually override the constraint mechanism for selected partitions. Using the \emph{force-level} clause a minimum zoom-level can be set for a given partition. Constraints are not evaluated for these partitions:

\begin{lstlisting}
FORCE MIN LEVEL
   {integer} FOR {partition}
AND
   {integer} FOR {partition}
...
\end{lstlisting}

\subsubsection{transform-by clause}

Finally, the user may optionally give list of named transformations in the \emph{transform-by} clause. CVL has support for two such transformations: simplification and a novel "all-or-nothing" transformation. The all-or-nothing transformation ensures that either all records in a partition are visible at a given zoom-level or none of them are.

\begin{lstlisting}
TRANSFORM BY
   [simplify], [all-or-nothing]
\end{lstlisting}

\subsection{Create constraint statement}

TODO

