% !TEX root = ./cvl.tex
\section{CVL language}
\label{sec:language}

As part of this work, we have designed the declarative language CVL, designed to enable a human cartographer to concisely state the decided properties of the output of a generalization process. CVL is an acronym for \emph{Cartographic Visualization Language} and the syntax and semantics of this language are defined in this section.

This declarative language has clauses, much like SQL, but is otherwise much simpler. There are two mandatory clauses, the first of which is a specification of the input source and fields and the name of the output dataset. CVL is designed to be compiled to SQL, so the input and output can be names of tables. The input dataset is assumed to exist at evaluation time, while the output dataset is created as part of executing the CVL script.

\begin{lstlisting}
GENERALIZE 
   {source} TO {target}
WITH ID
   {field}
WITH GEOMETRY 
   {field}
\end{lstlisting}

Optionally one can add a clause for other fields, which are simply copied from input to output:

\begin{lstlisting}
WITH OTHER {list of fields}
\end{lstlisting}

The second mandatory clause specifies the number of zoom-levels to generalize for. Zoom-levels are assumed to run from 0 (lowest scale) to some $\mathcal{Z}$ (largest scale). As zoom-levels are zero-indexed, the number that is given in the clause is $\mathcal{Z}-1$:

\begin{lstlisting}
AT {integer} ZOOM LEVELS
\end{lstlisting}

A ranking expression (e.g. a user defined function) is optionally given to guide the generalization process and give priority to "important" records. If the clause is left out, records are ranked by the constant $1$:

\begin{lstlisting}
RANK BY {float expr}
\end{lstlisting}

A partitioning expression (e.g. the name of a record field) is optionally given to semantically split the input dataset into subpartitions. Subpartitions are treated separately by the CVL interpreter. If no clause is given, all records are partitioned by the constant $1$. Optionally, the merge clause can be used to recombine partitions into bigger ones:

\begin{lstlisting}
PARTITION BY
   {scalar expr}
MERGE PARTITIONS    
    {partitons}
    AS {scalar expr}
[AND 
   {partitions} 
   AS {scalar expr}]
[...]
[AND 
   * AS {scalar expr}]
\end{lstlisting}

One of the most central clauses is actually optional. The subject-to clause states the cartographic constraints that must hold for each partition at each zoom-level. Constraint are parameterized by a single float-valued expression, typically a constant:

\begin{lstlisting}
SUBJECT TO 
   {constraint} {float parameters} 
[AND
   {constraint} {float parameters}]
[...]
\end{lstlisting}

The user may optionally choose to manually set the minimum zoom-level (integer) for a partition (scalar). Constraints are not evaluated for these partitions:

\begin{lstlisting}
FORCE MIN LEVEL
   {zoom-level} FOR {partition}
[AND
   {zoom-level} FOR {partition}]
[...]
\end{lstlisting}

The user may optionally name a set of finalizing steps to be performed at the end of the generalization process. CVL has support for two such steps: simplification and a novel "all-or-nothing" transformation. The all-or-nothing transformation ensures that either all records in a partition are visible at a given zoom-level or none of them are.

\begin{lstlisting}
TRANSFORM BY
   {operator} [, {operators}]
\end{lstlisting}

