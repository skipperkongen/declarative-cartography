% !TEX root = ./cvl.tex
\section{Language}
\label{sec:cvl-language}
Cartographic Visualization Language (CVL) is a declarative language for generalizing or thinning a spatial dataset for a set of zoom-levels. CVL is designed to be very concise, typically no more than ten lines of code, and to be usable by people with intermediate geographical and programming skills.

% add: motivated by experience of working with maps and such at grontmij and the agency. This type of skill set (geo + IT) is common among people who work with geospatial data in the public and private sectors. Add this argument before this section.

The language has only two statements, the \emph{generalize} statement and the \emph{create constraint} statement. The create constraint statement is used to augment CVL with new cartographic constraints.

\subsection{Overview}

% Add: explain how constraints in the subject-to clause expand into constraint on each level. Also explain 

In CVL all records are assigned a weight, and conditions are formulated that must hold for subsets of records. If a condition does not hold, it must be made to hold by deleting some of the records. This implies the following optimization problem: At every zoom level a possibly empty subset of records is deleted such that all conditions are made to hold and the sum of weights of records that are deleted is minimized.

The principle of constant information density~\cite{toepfer} states that the amount of information presented to a user browsing a map must remain equal at all zoom levels. The goal of CVL is to enable the user to enforce this principle in a user-defined way. The principle implies that subsets of records are removed from the map at lower scales. In automated cartographic generalization, the removal of records is guided by cartographic constraints~\cite{something}.

Other guiding principles for cartographic generalization exist~\cite{something}, but the principle of constant density is arguably the most important one. CVL therefore covers a large number of use cases for generalizing datasets.

\subsubsection{Cartographic constraints in CVL}

A cartographic constraint in CVL is a condition that must hold for any $K$-sized subset of records at a given zoom levels. If the condition does not hold, it must be made to hold by deleting a subset of the records at the given zoom level. An example of a constraint is the \emph{proximity constraint} which says that all pairs of records must be separated by at least some distance $d$ on the screen. Another constraint is the \emph{visibility constraint} which says that for all subsets of $K$ records at most $K-1$ records may intersect the same cell in a map tile model.

The situation where a constraint is violated can always be resolved by deleting a subset of the records at a given zoom level.

\subsubsection{Weighting records}
Instead of deleting records willy-nilly the deletion of records at the different zoom levels is guided by assigning a weight to each record. Higher weights imply more important records or records that we would rather not delete. Weights are assigned by evaluating a user defined expression over the set of records, which induces a partial order over the records with ties broken arbitrarily. Examples of assigning weights to records include using the output of a random number generator or the constant $1$. A more useful example is using a record attribute to partially order the records. For example in a restaurant dataset a star-rating may be used to partially order the records.

% Make statement section, make one big syntax box (one for each statement), get rid of clause subsubsections.  

\subsection{Generalize statement}
The generalize statement is used to transform an input spatial dataset to a multi-scale output dataset, which is well-suited for display on a zoomable map such as the web maps that have gained immense popularity over the last ten years. The generalize statement consists of several clauses. 

\subsubsection{input-output clause}

The \emph{input-output} clause is used to define input and output tables along with the names of key fields (id and geometry) in the input table:

\begin{lstlisting}
GENERALIZE 
   {input} TO {output}
WITH ID
   {field}
WITH GEOMETRY 
   {field}
WITH OTHER {list of fields}
\end{lstlisting}

The \emph{with-other} part is optional and is used to to list additional fields that should be copied from input to output.

\subsubsection{zoom-levels clause}

The \emph{zoom-levels} clause is parameterized by a positive integer which is the number of zoom-levels that the input should be generalized for. Zoom-levels run from 1 (lowest scale) to some positive integer $\mathcal{Z}$ (largest scale) typically less than the number 20:

\begin{lstlisting}
AT {integer} ZOOM LEVELS
\end{lstlisting}

\subsubsection{rank-by clause}

The \emph{rank by} clause is used to assign a weight to each record. It is parameterized by an expression that can be cast to a floating point number. The expression is anything that could used as a projection in an SQL select query, for example a call to the \texttt{random()} function or the name of a field:

\begin{lstlisting}
RANK BY {float expression}
\end{lstlisting}

If the clause is left out, records are ranked by the constant $1$

\subsubsection{subject-to clause}

The \emph{subject-to} clause is a list of cartographic constraints that should be enforced. Each element in the list is a tuple containing the name of a constraint as the first element followed by a set of floating point parameters. Constraints are created by using the \emph{create-constraint} statement (see Section~\ref{sec:create-constraint-statement}).

\begin{lstlisting}
SUBJECT TO 
   {constraint} {float parameters} 
AND
   {constraint} {float parameters}
...
\end{lstlisting}

\subsection{Create constraint statement}
\label{sec:create-constraint-statement}

% change text
A named cartographic constraints is created using the \emph{create constraint} statement. The body of the constraint is an SQL statement that selects a result consisting of tuples $\langle cid, rid, minhits \rangle$. It selects a tuple for every record that is part of a subset of records that violate a given constraint. To be precise, a record may be part of more than one subset. E.g. a record may violate the proximity constraint by being too close to more than one other record. The subsets are identified by a unique subset identifier $cid$,  the members of the subset are identified by record id $rid$ and $minhits$ is an integer that indicates how many records must be deleted from the subset in order to satisfy the constraint.

\begin{lstlisting}
CREATE CONSTRAINT C1
AS NOT EXISTS
  (SELECT cid, rid
   FROM  {more SQL})
RESOLVE cid IF DELETE (
  {integer expression}
)

\end{lstlisting}

\subsection{CVL framework functions and variables}

% give the variables by example, and explain together with the example, instead of listing everything up front.

Some utility functions and variables are given by the CVL framework. These can be used when writing constraint statements. The aim of these functions is to make it easier to write constraints. The functions are:

\minisec{CellSizeZ} yada yada

\minisec{ResolutionZ} yada yada

\minisec{PointHash} yada yada

\minisec{WebMercatorCells}
Takes as input a geometry and a zoom-level. Produces a set of points that correspond to the centers of intersected cells in standard Web Mercator tile model~\cite{osm?} at the given zoom-level.

A number of variables can be referenced inside the query:

\minisec{level-view} A view containing only the records that part of the currently active zoom level

\minisec{z} The currently active zoom level as an integer

\minisec{geometry} The name of the geometry field in the input

\minisec{parameter 1, ..., n} The values of the floating point parameters given in the subject-to clause.

Apart from these variables, CVL automatically creates the following fields in the output table: \emph{cvl-id}, \emph{cvl-rank} and \emph{cvl-zoom} which may additionally be used in the query.

\subsection{Examples of CVL}

TODO
