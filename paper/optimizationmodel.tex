% !TEX root = ./cvl.tex
\section{Multi-scale filtering optimization problem}
\label{sec:optimizationmodel}

In this section, we formally define the multi-scale filtering problem as an optimization problem. Let $R$ be the set of records in the dataset. Each record $r \in R$ has an associated weight $w_r > 0$ which models the importance of the record. As before, the zoom-levels run from 1 (lowest scale) to $\mathcal{Z}$ (largest scale). The overall task of the multi-scale filtering problem is to filter out records on each zoom level so that the remaining records fulfill a number of map constraints. A primary constraint is the \emph{zoom-consistency} constraint~\cite{sarma2012fusiontables}: when a record is filtered out at a given scale, it should also be filtered out at all lower scales. 

In addition to the zoom-consistency constraint there are a number of additional constraints (formulated as conflict sets) that are modeled using CVL. Let $C$ be the collection of conflict sets for all zoom levels; each conflict set $c \in C$ is associated with a given zoom level $z_c$. A conflict set $c \in C$ is a set of records $R_c \subseteq R$, where at least $\lambda_c \geq 1$ records must be filtered out at zoom level~$z_c$. 

%\marcos{Is a constraint above equivalent to a CVL constraint or to a conflict set?}

%\marcos{The sections below need a better connection to the concepts introduced in the language section.}

\subsection{Multi-scale filtering problem}

The multi-scale filtering problem can now be modeled as a 0-1 integer program. We have a 0-1 decision variable $x_{rz}$ for each record $r \in R$ and each zoom level $z \in \{1,\ldots, \mathcal{Z}\}$; this decision variable is 1 if record $r$ is \emph{filtered out} at zoom level $z$, and 0 otherwise. The mathematical optimization problem is:
\begin{align}
  \label{eq:objective}
  \min ~\sum_{r \in R} \sum_{z=1}^\mathcal{Z} &w_r x_{rz} \\
  \label{eq:zoom-consistency}
  \mbox{s.t.}~~~~~~~x_{rz} &\geq x_{rz'}, ~~~~r \in R, ~~1 \leq z < z' \leq \mathcal{Z} \\
  \label{eq:general-constraints}
  \sum_{r \in R_c, ~z = z_c} x_{rz} &\geq \lambda_c, ~~~~~~ c \in C \\
  x_{rz} & \in \{0, 1\}, ~~ r \in R, ~~1 \leq z \leq \mathcal{Z}
\end{align}

The goal (\ref{eq:objective}) is to minimize the total weight of the records that are filtered out across all zoom levels. Constraints~(\ref{eq:zoom-consistency}) enforce the zoom-consistency constraint, while constraints~(\ref{eq:general-constraints}) model the conflict sets $c \in C$; note that a given conflict set $c \in C$ is only active at its zoom level $z_c$, which means that it only involves decisions variables $x_{rz}$ where $z = z_c$.

\subsection{Single-scale filtering problem}

Although the multi-scale filtering problem is conceptually simple, it is not practical. On low scales the number of records involved in each conflict set can be huge --- in the order of thousands or millions --- making the problem infeasible to solve in practice. Thus we will solve the problem in a greedy fashion by solving the problem at the largest scale first (corresponding to zoom level $\mathcal{Z}$). The surviving records at zoom level $\mathcal{Z}$ then form the input to the problem at zoom level $\mathcal{Z}-1$ etc. In this manner, the zoom-consistency constraint is automatically fulfilled. Thus the multi-scale problem is broken down into $\mathcal{Z}$ single-scale problems.

Let $\bar{R} \subseteq R$ be the set of records that have survived up to a given zoom-level, and let $\bar{C}$ be the collection of active conflict sets at this zoom level. As before, $\bar{R}_c \subseteq \bar{R}$ denotes the set of records associated with conflict set $c \in \bar{C}$. Let $x_r$ be a 0-1 decision for each record $r \in \bar{R}$ that is 1 if record $r$ is filtered out, and 0 otherwise. Then the single-scale problem can be stated as follows:
\begin{align}
  \label{eq:objective-single}
  \min ~\sum_{r \in \bar{R}} &w_r x_r \\
  \label{eq:general-constraints-single}
  \sum_{r \in \bar{R}_c} x_r &\geq \lambda_c, ~~~~ c \in \bar{C} \\
  x_r & \in \{0, 1\}, ~~ r \in \bar{R}, ~c \in \bar{C}
\end{align}

This is the \emph{set multicover problem} --- a generalization of the well-known set cover problem where each element/conflict set $c \in C$ needs to be covered $\lambda_c \geq 1$ times by the sets/records $r \in R$; each set/record can be chosen at most once~\cite{rajagopalan1998primal}. 

In the next section we discuss algorithmic approaches for solving the single-scale problem. Note that although we solve the multi-scale problem as a series of single-scale problems, in the experimental evaluation of our approach also includes a discussion on the objective value (\ref{eq:objective}) of the \emph{multi-scale} problem. 

\marcos{Is the above really true of our experiments?}
\martin{That was the plan. Kostas, I hope that this is still true?}
